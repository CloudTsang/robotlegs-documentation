h2(#mvcs). MVCS参考实现

Robotlegs由一个参考实现装备. 这个实现遵照经典的Model-View-Controller (MVC)元设计模式, 另外增加了第四个叫做Service的actor. 这些层在本文档中通称为"核心actor", 或者简称为"actor".

MVCS提供一个应用程序的框架概况. 通过将几个经过时间检验的设计模式整合到一个具体实现, Robotlegs的MVCS实现可以用做创建你的应用程序的一致方案. 通过这些架构概念着手一个应用程序, 你甚至可以在开始你的设计之前避免很多常见的障碍:

* 分离
* 组织
* 解耦

h4. 分离

MVCS提供一种将你的应用程序分离到提供特定功能的无关联的层的很自然的方法. view层处理用户交互. model层处理用户创建的或从外部获取的数据. controller提供一种封装各层之间复杂交互的机制. 最后, service层提供一种和外界(比如远程服务API或文件系统)交互的独立机制.

h4. 组织

通过这种分离我们自然获得一个组织水平. 每个项目都需要某个组织水平. 是的, 有人可以把他们所有的类都扔到顶级包下完事, 但即使是最小的项目这也是不可接受的. 当一个项目有了一定的规模就需要开始组织类文件的结构了. 当增加团队成员到同一个应用程序开发中的时候问题就更加严重了. RobotLegs的MVCS实现为项目描绘出一个分为四层的优雅的组织结构.

h4. 解耦

Robotlegs的MVCS实现将应用程序解耦为4层. 每层都与其它层隔离, 使分离类和组件分别测试变得非常容易. 除了简化测试进程, 也通常使类更具便携性以在其它项目中使用. 比如, 一个连接到远程API的Service类可能在多个项目中都很有用. 通过解耦这个类, 它可以不需重构便从一个项目转移到另一个中使用.

这个默认实现打算充当最佳实践建议的一个例子. Robotlegs并不打算以任何方式束缚你到这个例子, 它只是作为一个建议而提供. 你可以随意开发自己的实现来适应你喜欢的命名规范和开发需求. 如果这正是你所追求的, 请一定告诉我们, 因为我们一直对新方案很感兴趣, 而且它有可能可以作为一种替代实现包含到RobotLegs的代码仓库中.

h3(#context). Context

像RobotLegs中的其它实现一样, MVCS实现也是围绕一个或多个Context. 这个context提供一个中心的event bus并且处理自己的启动和关闭. 一个context定义了一个范围. 框架actor们处在context之内，并且在context定义的范围之内进行相互间的通讯. 一个应用程序是可以有多个context的. 这对想要加载外部模块的应用程序很有用. 因为在一个context里的actor只能在他们的context定义的范围之内相互通讯, 所以在一个模块化的应用程序里, 不同context之间的通讯是完全可能的.

本文档不讨论模块化编程的内容. 之后本文档内所有提到的Context都指在一个应用程序里的单一的context.

h3(#controllersandcommands). Controller & Commands

Controller层由Command类体现. Commands是用来执行应用程序单一单位工作的, 无状态的, 短生命周期的对象. Command用于应用程序各层之间相互通讯， 也可能用来发送系统事件. 这些系统事件既可能发动其它的Command, 也可能被一个Mediator接收,然后对一个View Component进行对应这个事件的工作. Command是封装你的应用程序业务逻辑的绝佳场所.

h3(#viewandmediators). View & Mediators

View由Mediator类体现. 继承Mediator的类用来处理框架和View Component之间的交互. 一个Mediator将会监听框架事件和View Component事件, 并在处理所负责的View Component发出的事件时发送框架事件. 这样开发者可以将应用程序特有的逻辑放到Mediator, 而避免把View Component耦合到特定的应用程序.

h3(#modelandservice). Model, Service and the Actor

MVCS架构里的service和model在概念上有着非常多的相似之处. 因为这种相似性, model和service继承了同样的Actor基类. 继承Actor基类可以获得很多应用程序架构内的功能. 在MVCS的context里, 我们通过利用继承Actor基类来定义应用程序所需要用来管理数据以及和外界通讯的model和service类. 本文档将把model和service类分别叫做Model和Service.

澄清一点, 本文档把体现应用程序四个层的所有类都称为"framework actor"或"actor". 请不要和本例中包含的只被Model和Service类继承的MVCS类Actor混淆.

h4(#modelandmodels). Model

Model类用来在model层对数据进行封装并为其提供API. Model会在对数据模型进行某些工作之后发出事件通知. Model通常具有极高的便携性.

h4(#serviceandservices). Service

一个service层的Service用来和"外面的世界"进行通讯. Web service, 文件存取, 或者其它任何应用程序范围之外的行为对service类都很合适. Service类在处理外部事件时会广播系统事件. 一个service应该封装和外部服务的交互且具有非常高的便携性.

h3(#frameworkevents). 框架事件

Robotlegs使用Flash的原生事件用于框架actor之间的通讯. 自定义类通常用于此用途, 虽然使用现有的Flash事件同样可行. Robotlegs不支持事件冒泡, 因为它并不依赖Flash显示列表作为event bus. 使用自定义类允许开发者给事件添加属性来为框架actor之间通讯的系统事件提供强类型的负载.

所有的框架actor都可以发送事件: Mediator, Service, Model, 和 Command. Mediator是唯一接收框架事件的actor. Command是在框架事件的处理中被触发. 一个事件既可以被一个Mediator接收, 也可以出发一个command.

model和service不应该监听和处理事件. 这样做会把它们紧耦合到应用程序特有逻辑而降低潜在的便携性和复用性.

