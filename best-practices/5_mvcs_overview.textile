h2(#mvcs). MVC+S Reference Implementation

Robotlegs is equipped with a reference implementation. This implementation follows the classic meta-design pattern known as Model-View-Controller (MVC), with the addition of a fourth actor called Service. These tiers, throughout this document, are referred to as the "Core actors," or simply "actors."

This standard, or default implementation is meant to serve as an example of suggested best practices. Robotlegs does not intend to tie you to this example in any way, but it is provided as a suggestion. You are free to develop your own implementation to suit your favored nomenclature and development needs. If this is something you pursue, please let us know about it, as we are always interested in new approaches and it can potentially be included in the Robotlegs repository as an alternate implementation.

h3(#context). Context

Like all Robotlegs implementations the MVC+S implementation is centered around one or more Contexts. The context provides a central event bus and takes care of startup and shutdown of the Context.

h3(#modelandmodels). Model & Models

The Model tier is represented by the Model class. Classes that extend Model encapsulate and provide an API for data. Models send event notifications when work has been performed on the data model. Models are generally highly portable entities.

h3(#viewandmediators). View & Mediators

The View tier is represented by the Mediator class. Classes that extend Mediator are used to handle framework interaction with View Components. A Mediator will listen for framework events, add event listeners to the View Components, and send framework events in response to events received from the View Components they are responsible for. This allows the developer to put application specific logic on the Mediator, and avoid coupling View components to specific applications. 

h3(#controllersandcommands). Controller & Commands

The Controller tier is represented by the Command class. Commands are stateless, short-lived objects used to perform a single unit of work within an application. Commands are appropriate for communication between application tiers and are able to send system events that will either launch other Commands or be received by a Mediator to perform work on a View Component in response to the event. Commands are an excellent place to encapsulate the business logic of your application.

h3(#serviceandservices). Service & Services

The Service tier is represented by the Service class. A class that extends Service is essentially a model for communicating with "the outside world" from within an application. Web services, file access, or any action that takes place outside of the scope of your application is appropriate for the Service class. Service classes dispatch system events in response to external events. A Service should be highly portable, encapsulating interaction with an external service.

h3(#frameworkevents). Framework Events

Robotlegs uses native flash events for communication between framework actors. Custom events are typically utilized for this purpose, it is however possible to use existing Flash events for this same purpose. Robotlegs does not support Event bubbling, as it does not depend on the Flash display list as an event bus. Utilizing custom events allows developers to add properties to the Event that can be used as strongly typed payloads for system events between framework actors.

Events are sent from all framework actors: Mediators, Models, and Commands. Mediators are the only actors that receive framework events. Commands are triggered in response to framework events. An event can be both received by a Mediator as well as trigger a command.

Models and Services to not listen for or respond to events. Doing so would tightly couple them to application specific logic and reduce the potential for portability and reuse.